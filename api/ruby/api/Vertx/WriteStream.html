<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>
  Module: Vertx::WriteStream
  
    &mdash; vert.x Ruby API
  
</title>

  <link rel="stylesheet" href="../css/style.css" type="text/css" media="screen" charset="utf-8" />

  <link rel="stylesheet" href="../css/common.css" type="text/css" media="screen" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  relpath = '..';
  if (relpath != '') relpath += '/';
</script>

  <script type="text/javascript" charset="utf-8" src="../js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="../js/app.js"></script>


  </head>
  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>
    
    <div id="header">
      <div id="menu">
  
    <a href="../_index.html">Index (W)</a> &raquo; 
    <span class='title'><span class='object_link'><a href="../Vertx.html" title="Vertx (module)">Vertx</a></span></span>
     &raquo; 
    <span class="title">WriteStream</span>
  
  
  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  
    <a id="class_list_link" href="#">Class List</a>
  
    <a id="method_list_link" href="#">Method List</a>
  
    <a id="file_list_link" href="#">File List</a>
  
</div>
      <div class="clear"></div>
    </div>
    
    <iframe id="search_frame"></iframe>
    
    <div id="content"><h1>Module: Vertx::WriteStream
  
  
  
</h1>

<dl class="box">
  
  
    
  
    
  
  
    <dt class="r1">Included in:</dt>
    <dd class="r1"><span class='object_link'><a href="HttpClientRequest.html" title="Vertx::HttpClientRequest (class)">HttpClientRequest</a></span>, <span class='object_link'><a href="HttpServerResponse.html" title="Vertx::HttpServerResponse (class)">HttpServerResponse</a></span>, <span class='object_link'><a href="NetSocket.html" title="Vertx::NetSocket (class)">NetSocket</a></span>, <span class='object_link'><a href="SockJSSocket.html" title="Vertx::SockJSSocket (class)">SockJSSocket</a></span>, <span class='object_link'><a href="WebSocket.html" title="Vertx::WebSocket (class)">WebSocket</a></span></dd>
    
  
  
    <dt class="r2 last">Defined in:</dt>
    <dd class="r2 last">src/main/ruby/core/streams.rb</dd>
  
</dl>
<div class="clear"></div>

<h2>Overview</h2><div class="docstring">
  <div class="discussion">
    <p>
A mixin module which represents a stream of data that can be written to.
</p>
<p>
Any class that mixes in this module can be used by a <span class='object_link'><a href="Pump.html" title="Vertx::Pump (class)">Pump</a></span> to pump data
from a <span class='object_link'><a href="ReadStream.html" title="Vertx::ReadStream (module)">ReadStream</a></span> to it.
</p>


  </div>
</div>
<div class="tags">
  
<h3>Author:</h3>
<ul class="author">
  
    <li>
      
      
      
      
        
        <div class='inline'><p>
<a href="http://tfox.org" target="_parent" title="Tim Fox">Tim Fox</a>
</p>
</div>
      
    </li>
  
</ul>

</div>






  
    <h2>
      Instance Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#drain_handler-instance_method" title="#drain_handler (instance method)">- (Object) <strong>drain_handler</strong>(&amp;hndlr) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Set a drain handler on the stream.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exception_handler-instance_method" title="#exception_handler (instance method)">- (Object) <strong>exception_handler</strong>(&amp;hndlr) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Set an execption handler on the stream.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#write_buffer-instance_method" title="#write_buffer (instance method)">- (Object) <strong>write_buffer</strong>(buff) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Write some data to the stream.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#write_queue_full%3F-instance_method" title="#write_queue_full? (instance method)">- (Boolean) <strong>write_queue_full?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Is the write queue full?.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#write_queue_max_size%3D-instance_method" title="#write_queue_max_size= (instance method)">- (Object) <strong>write_queue_max_size=</strong>(size) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Set the maximum size of the write queue.
</p>
</div></span>
  
</li>

      
    </ul>
  



  <div id="instance_method_details" class="method_details_list">
    <h2>Instance Method Details</h2>
    
    
      <div class="method_details first">
  <p class="signature first" id="drain_handler-instance_method">
  
    - (<tt>Object</tt>) <strong>drain_handler</strong>(&amp;hndlr) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Set a drain handler on the stream. If the write queue is full, then the
handler will be called when the write queue has been reduced to maxSize /
2. See <span class='object_link'><a href="Pump.html" title="Vertx::Pump (class)">Pump</a></span> for an example of this being used.
</p>


  </div>
</div>
<div class="tags">
  <h3>Parameters:</h3>
<ul class="param">
  
    <li>
      
        <span class='name'>hndlr.</span>
      
      
        <span class='type'>(<tt>Block</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>
The drain handler
</p>
</div>
      
    </li>
  
</ul>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


49
50
51</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'src/main/ruby/core/streams.rb', line 49</span>

<span class='rubyid_def def kw'>def</span> <span class='rubyid_drain_handler identifier id'>drain_handler</span><span class='lparen token'>(</span><span class='bitand op'>&amp;</span><span class='rubyid_hndlr identifier id'>hndlr</span><span class='rparen token'>)</span>
  <span class='rubyid_@j_del ivar id'>@j_del</span><span class='dot token'>.</span><span class='rubyid_drainHandler identifier id'>drainHandler</span><span class='lparen token'>(</span><span class='rubyid_hndlr identifier id'>hndlr</span><span class='rparen token'>)</span>
<span class='rubyid_end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="exception_handler-instance_method">
  
    - (<tt>Object</tt>) <strong>exception_handler</strong>(&amp;hndlr) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Set an execption handler on the stream.
</p>


  </div>
</div>
<div class="tags">
  <h3>Parameters:</h3>
<ul class="param">
  
    <li>
      
        <span class='name'>hndlr.</span>
      
      
        <span class='type'>(<tt>Block</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>
The exception handler
</p>
</div>
      
    </li>
  
</ul>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


55
56
57</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'src/main/ruby/core/streams.rb', line 55</span>

<span class='rubyid_def def kw'>def</span> <span class='rubyid_exception_handler identifier id'>exception_handler</span><span class='lparen token'>(</span><span class='bitand op'>&amp;</span><span class='rubyid_hndlr identifier id'>hndlr</span><span class='rparen token'>)</span>
  <span class='rubyid_@j_del ivar id'>@j_del</span><span class='dot token'>.</span><span class='rubyid_exceptionHandler identifier id'>exceptionHandler</span><span class='lparen token'>(</span><span class='rubyid_hndlr identifier id'>hndlr</span><span class='rparen token'>)</span>
<span class='rubyid_end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="write_buffer-instance_method">
  
    - (<tt>Object</tt>) <strong>write_buffer</strong>(buff) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Write some data to the stream. The data is put on an internal write queue,
and the write actually happens asynchronously. To avoid running out of
memory by putting too much on the write queue, check the
<span class='object_link'><a href="#write_queue_full%3F-instance_method" title="Vertx::WriteStream#write_queue_full? (method)">#write_queue_full?</a></span> method before writing. This is done automatically if
using a <span class='object_link'><a href="Pump.html" title="Vertx::Pump (class)">Pump</a></span>.
</p>


  </div>
</div>
<div class="tags">
  <h3>Parameters:</h3>
<ul class="param">
  
    <li>
      
        <span class='name'>.</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Buffer.html" title="Vertx::Buffer (class)">Buffer</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>
The buffer to write.
</p>
</div>
      
    </li>
  
</ul>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


28
29
30</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'src/main/ruby/core/streams.rb', line 28</span>

<span class='rubyid_def def kw'>def</span> <span class='rubyid_write_buffer identifier id'>write_buffer</span><span class='lparen token'>(</span><span class='rubyid_buff identifier id'>buff</span><span class='rparen token'>)</span>
  <span class='rubyid_@j_del ivar id'>@j_del</span><span class='dot token'>.</span><span class='rubyid_writeBuffer identifier id'>writeBuffer</span><span class='lparen token'>(</span><span class='rubyid_buff identifier id'>buff</span><span class='dot token'>.</span><span class='rubyid__to_java_buffer identifier id'>_to_java_buffer</span><span class='rparen token'>)</span>
<span class='rubyid_end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="write_queue_full?-instance_method">
  
    - (<tt>Boolean</tt>) <strong>write_queue_full?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Is the write queue full?
</p>


  </div>
</div>
<div class="tags">
  
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>
true if there are more bytes in the write queue than the max write queue
size.
</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


42
43
44</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'src/main/ruby/core/streams.rb', line 42</span>

<span class='rubyid_def def kw'>def</span> <span class='rubyid_write_queue_full? fid id'>write_queue_full?</span>
  <span class='rubyid_@j_del ivar id'>@j_del</span><span class='dot token'>.</span><span class='rubyid_writeQueueFull identifier id'>writeQueueFull</span>
<span class='rubyid_end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="write_queue_max_size=-instance_method">
  
    - (<tt>Object</tt>) <strong>write_queue_max_size=</strong>(size) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Set the maximum size of the write queue. You will still be able to write to
the stream even if there is more data than this in the write queue. This is
used as an indicator by classes such as <span class='object_link'><a href="Pump.html" title="Vertx::Pump (class)">Pump</a></span> to provide flow control.
</p>


  </div>
</div>
<div class="tags">
  <h3>Parameters:</h3>
<ul class="param">
  
    <li>
      
        <span class='name'>size.</span>
      
      
        <span class='type'>(<tt>FixNum</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>
The maximum size, in bytes.
</p>
</div>
      
    </li>
  
</ul>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


36
37
38</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'src/main/ruby/core/streams.rb', line 36</span>

<span class='rubyid_def def kw'>def</span> <span class='rubyid_write_queue_max_size= identifier id'>write_queue_max_size=</span><span class='lparen token'>(</span><span class='rubyid_size identifier id'>size</span><span class='rparen token'>)</span>
  <span class='rubyid_@j_del ivar id'>@j_del</span><span class='dot token'>.</span><span class='rubyid_setWriteQueueMaxSize identifier id'>setWriteQueueMaxSize</span><span class='lparen token'>(</span><span class='rubyid_size identifier id'>size</span><span class='rparen token'>)</span>
<span class='rubyid_end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

</div>
    
    <div id="footer">
  Generated on Tue Jun 19 16:38:26 2012 by 
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.7.5 (ruby-1.8.7).
</div>

  </body>
</html>