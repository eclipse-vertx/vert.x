<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>
  Class: Vertx::HttpClientRequest
  
    &mdash; vert.x Ruby API
  
</title>

  <link rel="stylesheet" href="../css/style.css" type="text/css" media="screen" charset="utf-8" />

  <link rel="stylesheet" href="../css/common.css" type="text/css" media="screen" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  relpath = '..';
  if (relpath != '') relpath += '/';
</script>

  <script type="text/javascript" charset="utf-8" src="../js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="../js/app.js"></script>


  </head>
  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>
    
    <div id="header">
      <div id="menu">
  
    <a href="../_index.html">Index (H)</a> &raquo; 
    <span class='title'><span class='object_link'><a href="../Vertx.html" title="Vertx (module)">Vertx</a></span></span>
     &raquo; 
    <span class="title">HttpClientRequest</span>
  
  
  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  
    <a id="class_list_link" href="#">Class List</a>
  
    <a id="method_list_link" href="#">Method List</a>
  
    <a id="file_list_link" href="#">File List</a>
  
</div>
      <div class="clear"></div>
    </div>
    
    <iframe id="search_frame"></iframe>
    
    <div id="content"><h1>Class: Vertx::HttpClientRequest
  
  
  
</h1>

<dl class="box">
  
    <dt class="r1">Inherits:</dt>
    <dd class="r1">
      <span class="inheritName">Object</span>
      
        <ul class="fullTree">
          <li>Object</li>
          
            <li class="next">Vertx::HttpClientRequest</li>
          
        </ul>
        <a href="#" class="inheritanceTree">show all</a>
      
      </dd>
    
  
  
    
  
    
      <dt class="r2">Includes:</dt>
      <dd class="r2"><span class='object_link'><a href="WriteStream.html" title="Vertx::WriteStream (module)">WriteStream</a></span></dd>
      
    
  
  
  
    <dt class="r1 last">Defined in:</dt>
    <dd class="r1 last">src/main/ruby/core/http.rb</dd>
  
</dl>
<div class="clear"></div>

<h2>Overview</h2><div class="docstring">
  <div class="discussion">
    <p>
Encapsulates a client-side HTTP request.
</p>
<p>
Instances of this class are created by an <span class='object_link'><a href="HttpClient.html" title="Vertx::HttpClient (class)">HttpClient</a></span> instance, via one of
the methods corresponding to the specific HTTP methods, or the generic
<span class='object_link'><a href="HttpClient.html#request-instance_method" title="Vertx::HttpClient#request (method)">Vertx::HttpClient#request</a></span> method.
</p>
<p>
Once an instance of this class has been obtained, headers can be set on it,
and data can be written to its body, if required. Once you are ready to
send the request, the <span class='object_link'><a href="#end-instance_method" title="Vertx::HttpClientRequest#end (method)">#end</a></span> method must called.
</p>
<p>
Nothing is sent until the request has been internally assigned an HTTP
connection. The <span class='object_link'><a href="HttpClient.html" title="Vertx::HttpClient (class)">HttpClient</a></span> instance will return an instance of this class
immediately, even if there are no HTTP connections available in the pool.
Any requests sent before a connection is assigned will be queued internally
and actually sent when an HTTP connection becomes available from the pool.
</p>
<p>
The headers of the request are actually sent either when the <span class='object_link'><a href="#end-instance_method" title="Vertx::HttpClientRequest#end (method)">#end</a></span> method
is called, or, when the first part of the body is written, whichever occurs
first.
</p>
<p>
This class supports both chunked and non-chunked HTTP.
</p>
<p>
An example of using this class is as follows:
</p>


  </div>
</div>
<div class="tags">
  
  <div class="examples">
    <h3>Examples:</h3>
    
      <h4><div class='inline'></div></h4>
      <pre class="example code">
<span class='rubyid_req identifier id'>req</span> <span class='assign token'>=</span> <span class='rubyid_httpClient identifier id'>httpClient</span><span class='dot token'>.</span><span class='rubyid_post identifier id'>post</span><span class='lparen token'>(</span><span class='string val'>&quot;/some-url&quot;</span><span class='rparen token'>)</span> <span class='rubyid_do do kw'>do</span> <span class='bitor op'>|</span><span class='rubyid_response identifier id'>response</span><span class='bitor op'>|</span>
  <span class='rubyid_puts identifier id'>puts</span> <span class='dstring node'>&quot;Got response #{response.status_code}&quot;</span>
<span class='rubyid_end end kw'>end</span>

<span class='rubyid_req identifier id'>req</span><span class='dot token'>.</span><span class='rubyid_put_header identifier id'>put_header</span><span class='lparen token'>(</span><span class='string val'>&quot;some-header&quot;</span><span class='comma token'>,</span> <span class='string val'>&quot;hello&quot;</span><span class='rparen token'>)</span>

<span class='rubyid_req identifier id'>req</span><span class='dot token'>.</span><span class='rubyid_chunked identifier id'>chunked</span> <span class='assign token'>=</span> <span class='rubyid_true true kw'>true</span>
<span class='rubyid_req identifier id'>req</span><span class='dot token'>.</span><span class='rubyid_write identifier id'>write</span><span class='lparen token'>(</span><span class='rubyid_Buffer constant id'>Buffer</span><span class='dot token'>.</span><span class='rubyid_create_from_str identifier id'>create_from_str</span><span class='lparen token'>(</span><span class='string val'>&quot;chunk of body 1&quot;</span><span class='rparen token'>)</span><span class='semicolon token'>;</span>
<span class='rubyid_req identifier id'>req</span><span class='dot token'>.</span><span class='rubyid_write identifier id'>write</span><span class='lparen token'>(</span><span class='rubyid_Buffer constant id'>Buffer</span><span class='dot token'>.</span><span class='rubyid_create_from_str identifier id'>create_from_str</span><span class='lparen token'>(</span><span class='string val'>&quot;chunk of body 2&quot;</span><span class='rparen token'>)</span><span class='semicolon token'>;</span>

<span class='rubyid_req identifier id'>req</span><span class='dot token'>.</span><span class='rubyid_end identifier id'>end</span><span class='lparen token'>(</span><span class='rparen token'>)</span><span class='semicolon token'>;</span> <span class='comment val'># This actually sends the request</span>
</pre>
    
  </div>

<h3>Author:</h3>
<ul class="author">
  
    <li>
      
      
      
      
        
        <div class='inline'><p>
<a href="http://tfox.org" target="_parent" title="Tim Fox">Tim Fox</a>
</p>
</div>
      
    </li>
  
</ul>

</div>






  
    <h2>
      Instance Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#chunked%3D-instance_method" title="#chunked= (instance method)">- (HttpClientRequest) <strong>chunked=</strong>(val) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Sets whether the request should used HTTP chunked encoding or not.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#continue_handler-instance_method" title="#continue_handler (instance method)">- (Object) <strong>continue_handler</strong>(proc = nil, &amp;hndlr) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
If you send an HTTP request with the header &#8216;Expect&#8217; set to the
value &#8216;100-continue&#8217; and the server responds with an interim
HTTP response with a status code of &#8216;100&#8217; and a continue
handler has been set using this method, then the handler will be called.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#end-instance_method" title="#end (instance method)">- (Object) <strong>end</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Ends the request.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#headers-instance_method" title="#headers (instance method)">- (Object) <strong>headers</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Hash of headers for the request.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#put_header-instance_method" title="#put_header (instance method)">- (HttpClientRequest) <strong>put_header</strong>(key, value) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Inserts a header into the request.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#send_head-instance_method" title="#send_head (instance method)">- (HttpClientRequest) <strong>send_head</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Forces the head of the request to be written before <span class='object_link'><a href="#end-instance_method" title="Vertx::HttpClientRequest#end (method)">#end</a></span> is called on the
request.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#write_buffer-instance_method" title="#write_buffer (instance method)">- (HttpClientRequest) <strong>write_buffer</strong>(chunk, &amp;hndlr) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Write a [Buffer] to the request body.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#write_buffer_and_end-instance_method" title="#write_buffer_and_end (instance method)">- (Object) <strong>write_buffer_and_end</strong>(chunk) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Same as <span class='object_link'><a href="#end-instance_method" title="Vertx::HttpClientRequest#end (method)">#end</a></span> but writes some data to the response body before ending.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#write_str-instance_method" title="#write_str (instance method)">- (HttpClientRequest) <strong>write_str</strong>(str, enc = &quot;UTF-8&quot;, &amp;hndlr) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Write a [String] to the request body.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#write_str_and_end-instance_method" title="#write_str_and_end (instance method)">- (Object) <strong>write_str_and_end</strong>(str, enc = &quot;UTF-8&quot;) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Same as <span class='object_link'><a href="#write_buffer_and_end-instance_method" title="Vertx::HttpClientRequest#write_buffer_and_end (method)">#write_buffer_and_end</a></span> but writes a String.
</p>
</div></span>
  
</li>

      
    </ul>
  


  
  
  
  
  
  
  
  <h3 class="inherited">Methods included from <span class='object_link'><a href="WriteStream.html" title="Vertx::WriteStream (module)">WriteStream</a></span></h3>
  <p class="inherited"><span class='object_link'><a href="WriteStream.html#drain_handler-instance_method" title="Vertx::WriteStream#drain_handler (method)">#drain_handler</a></span>, <span class='object_link'><a href="WriteStream.html#exception_handler-instance_method" title="Vertx::WriteStream#exception_handler (method)">#exception_handler</a></span>, <span class='object_link'><a href="WriteStream.html#write_queue_full%3F-instance_method" title="Vertx::WriteStream#write_queue_full? (method)">#write_queue_full?</a></span>, <span class='object_link'><a href="WriteStream.html#write_queue_max_size%3D-instance_method" title="Vertx::WriteStream#write_queue_max_size= (method)">#write_queue_max_size=</a></span></p>


  <div id="instance_method_details" class="method_details_list">
    <h2>Instance Method Details</h2>
    
    
      <div class="method_details first">
  <p class="signature first" id="chunked=-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="Vertx::HttpClientRequest (class)">HttpClientRequest</a></span></tt>) <strong>chunked=</strong>(val) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Sets whether the request should used HTTP chunked encoding or not. will
correspond to a new HTTP chunk sent on the wire. If chunked encoding is
used the HTTP header &#8216;Transfer-Encoding&#8217; with a value of
&#8216;Chunked&#8217; will be automatically inserted in the request. If
chunked is false, this request will not use HTTP chunked encoding, and
therefore if any data is written the body of the request, the total size of
that data must be set in the &#8216;Content-Length&#8217; header before any
data is written to the request body.
</p>


  </div>
</div>
<div class="tags">
  <h3>Parameters:</h3>
<ul class="param">
  
    <li>
      
        <span class='name'>val.</span>
      
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>
If val is true, this request will use HTTP chunked encoding, and each call
to write to the body
</p>
</div>
      
    </li>
  
</ul>

<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Vertx::HttpClientRequest (class)">HttpClientRequest</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>
self So multiple operations can be chained.
</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


390
391
392
393</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'src/main/ruby/core/http.rb', line 390</span>

<span class='rubyid_def def kw'>def</span> <span class='rubyid_chunked= identifier id'>chunked=</span><span class='lparen token'>(</span><span class='rubyid_val identifier id'>val</span><span class='rparen token'>)</span>
  <span class='rubyid_@j_del ivar id'>@j_del</span><span class='dot token'>.</span><span class='rubyid_setChunked identifier id'>setChunked</span><span class='lparen token'>(</span><span class='rubyid_val identifier id'>val</span><span class='rparen token'>)</span>
  <span class='rubyid_self self kw'>self</span>
<span class='rubyid_end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="continue_handler-instance_method">
  
    - (<tt>Object</tt>) <strong>continue_handler</strong>(proc = nil, &amp;hndlr) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
If you send an HTTP request with the header &#8216;Expect&#8217; set to the
value &#8216;100-continue&#8217; and the server responds with an interim
HTTP response with a status code of &#8216;100&#8217; and a continue
handler has been set using this method, then the handler will be called.
You can then continue to write data to the request body and later end it.
This is normally used in conjunction with the <span class='object_link'><a href="#send_head-instance_method" title="Vertx::HttpClientRequest#send_head (method)">#send_head</a></span> method to force
the request header to be written before the request has ended.
</p>


  </div>
</div>
<div class="tags">
  <h3>Parameters:</h3>
<ul class="param">
  
    <li>
      
        <span class='name'>proc.</span>
      
      
        <span class='type'>(<tt>Proc</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>
The handler
</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>hndlr.</span>
      
      
        <span class='type'>(<tt>Block</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>
The handler
</p>
</div>
      
    </li>
  
</ul>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


402
403
404
405</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'src/main/ruby/core/http.rb', line 402</span>

<span class='rubyid_def def kw'>def</span> <span class='rubyid_continue_handler identifier id'>continue_handler</span><span class='lparen token'>(</span><span class='rubyid_proc identifier id'>proc</span> <span class='assign token'>=</span> <span class='rubyid_nil nil kw'>nil</span><span class='comma token'>,</span> <span class='bitand op'>&amp;</span><span class='rubyid_hndlr identifier id'>hndlr</span><span class='rparen token'>)</span>
  <span class='rubyid_hndlr identifier id'>hndlr</span> <span class='assign token'>=</span> <span class='rubyid_proc identifier id'>proc</span> <span class='rubyid_if if_mod kw'>if</span> <span class='rubyid_proc identifier id'>proc</span>
  <span class='rubyid_@j_del ivar id'>@j_del</span><span class='dot token'>.</span><span class='rubyid_continueHandler identifier id'>continueHandler</span><span class='lparen token'>(</span><span class='rubyid_hndlr identifier id'>hndlr</span><span class='rparen token'>)</span>
<span class='rubyid_end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="end-instance_method">
  
    - (<tt>Object</tt>) <strong>end</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Ends the request. If no data has been written to the request body, and
<span class='object_link'><a href="#send_head-instance_method" title="Vertx::HttpClientRequest#send_head (method)">#send_head</a></span> has not been called then the actual request won&#8217;t get
written until this method gets called. Once the request has ended, it
cannot be used any more, and if keep alive is true the underlying
connection will be returned to the <span class='object_link'><a href="HttpClient.html" title="Vertx::HttpClient (class)">Vertx::HttpClient</a></span> pool so it can be assigned
to another request.
</p>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


364</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'src/main/ruby/core/http.rb', line 364</span>

<span class='rubyid_def def kw'>def</span> <span class='rubyid_end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="headers-instance_method">
  
    - (<tt>Object</tt>) <strong>headers</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Hash of headers for the request
</p>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


317
318
319
320
321
322</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'src/main/ruby/core/http.rb', line 317</span>

<span class='rubyid_def def kw'>def</span> <span class='rubyid_headers identifier id'>headers</span>
  <span class='rubyid_if if kw'>if</span> <span class='notop op'>!</span><span class='rubyid_@headers ivar id'>@headers</span>
    <span class='rubyid_@headers ivar id'>@headers</span> <span class='assign token'>=</span> <span class='rubyid_@j_del ivar id'>@j_del</span><span class='dot token'>.</span><span class='rubyid_headers identifier id'>headers</span>
  <span class='rubyid_end end kw'>end</span>
  <span class='rubyid_@headers ivar id'>@headers</span>
<span class='rubyid_end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="put_header-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="Vertx::HttpClientRequest (class)">HttpClientRequest</a></span></tt>) <strong>put_header</strong>(key, value) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Inserts a header into the request.
</p>


  </div>
</div>
<div class="tags">
  <h3>Parameters:</h3>
<ul class="param">
  
    <li>
      
        <span class='name'>key</span>
      
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>
The header key
</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>value</span>
      
      
        <span class='type'>(<tt>Object</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>
The header value. to_s will be called on the value to determine the actual
String value to insert.
</p>
</div>
      
    </li>
  
</ul>

<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Vertx::HttpClientRequest (class)">HttpClientRequest</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>
self So multiple operations can be chained.
</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


328
329
330
331</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'src/main/ruby/core/http.rb', line 328</span>

<span class='rubyid_def def kw'>def</span> <span class='rubyid_put_header identifier id'>put_header</span><span class='lparen token'>(</span><span class='rubyid_key identifier id'>key</span><span class='comma token'>,</span> <span class='rubyid_value identifier id'>value</span><span class='rparen token'>)</span>
  <span class='rubyid_@j_del ivar id'>@j_del</span><span class='dot token'>.</span><span class='rubyid_putHeader identifier id'>putHeader</span><span class='lparen token'>(</span><span class='rubyid_key identifier id'>key</span><span class='comma token'>,</span> <span class='rubyid_value identifier id'>value</span><span class='dot token'>.</span><span class='rubyid_to_s identifier id'>to_s</span><span class='rparen token'>)</span>
  <span class='rubyid_self self kw'>self</span>
<span class='rubyid_end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="send_head-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="Vertx::HttpClientRequest (class)">HttpClientRequest</a></span></tt>) <strong>send_head</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Forces the head of the request to be written before <span class='object_link'><a href="#end-instance_method" title="Vertx::HttpClientRequest#end (method)">#end</a></span> is called on the
request. This is normally used to implement HTTP 100-continue handling, see
<span class='object_link'><a href="#continue_handler-instance_method" title="Vertx::HttpClientRequest#continue_handler (method)">#continue_handler</a></span> for more information.
</p>


  </div>
</div>
<div class="tags">
  
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Vertx::HttpClientRequest (class)">HttpClientRequest</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>
self So multiple operations can be chained.
</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


355
356
357
358</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'src/main/ruby/core/http.rb', line 355</span>

<span class='rubyid_def def kw'>def</span> <span class='rubyid_send_head identifier id'>send_head</span>
  <span class='rubyid_@j_del ivar id'>@j_del</span><span class='dot token'>.</span><span class='rubyid_sendHead identifier id'>sendHead</span>
  <span class='rubyid_self self kw'>self</span>
<span class='rubyid_end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="write_buffer-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="Vertx::HttpClientRequest (class)">HttpClientRequest</a></span></tt>) <strong>write_buffer</strong>(chunk, &amp;hndlr) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Write a [Buffer] to the request body.
</p>


  </div>
</div>
<div class="tags">
  <h3>Parameters:</h3>
<ul class="param">
  
    <li>
      
        <span class='name'>chunk.</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Buffer.html" title="Vertx::Buffer (class)">Buffer</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>
The buffer to write.
</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>hndlr.</span>
      
      
        <span class='type'>(<tt>Block</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>
The handler will be called when the buffer has actually been written to the
wire.
</p>
</div>
      
    </li>
  
</ul>

<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Vertx::HttpClientRequest (class)">HttpClientRequest</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>
self So multiple operations can be chained.
</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


337
338
339
340</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'src/main/ruby/core/http.rb', line 337</span>

<span class='rubyid_def def kw'>def</span> <span class='rubyid_write_buffer identifier id'>write_buffer</span><span class='lparen token'>(</span><span class='rubyid_chunk identifier id'>chunk</span><span class='comma token'>,</span> <span class='bitand op'>&amp;</span><span class='rubyid_hndlr identifier id'>hndlr</span><span class='rparen token'>)</span>
  <span class='rubyid_@j_del ivar id'>@j_del</span><span class='dot token'>.</span><span class='rubyid_writeBuffer identifier id'>writeBuffer</span><span class='lparen token'>(</span><span class='rubyid_chunk identifier id'>chunk</span><span class='dot token'>.</span><span class='rubyid__to_java_buffer identifier id'>_to_java_buffer</span><span class='rparen token'>)</span>
  <span class='rubyid_self self kw'>self</span>
<span class='rubyid_end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="write_buffer_and_end-instance_method">
  
    - (<tt>Object</tt>) <strong>write_buffer_and_end</strong>(chunk) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Same as <span class='object_link'><a href="#end-instance_method" title="Vertx::HttpClientRequest#end (method)">#end</a></span> but writes some data to the response body before ending. If
the response is not chunked and no other data has been written then the
Content-Length header will be automatically set
</p>


  </div>
</div>
<div class="tags">
  <h3>Parameters:</h3>
<ul class="param">
  
    <li>
      
        <span class='name'>chunk</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Buffer.html" title="Vertx::Buffer (class)">Buffer</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>
The Buffer to write
</p>
</div>
      
    </li>
  
</ul>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


378
379
380</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'src/main/ruby/core/http.rb', line 378</span>

<span class='rubyid_def def kw'>def</span> <span class='rubyid_write_buffer_and_end identifier id'>write_buffer_and_end</span><span class='lparen token'>(</span><span class='rubyid_chunk identifier id'>chunk</span><span class='rparen token'>)</span>
  <span class='rubyid_@j_del ivar id'>@j_del</span><span class='dot token'>.</span><span class='rubyid_end identifier id'>end</span><span class='lparen token'>(</span><span class='rubyid_chunk identifier id'>chunk</span><span class='dot token'>.</span><span class='rubyid__to_java_buffer identifier id'>_to_java_buffer</span><span class='rparen token'>)</span>
<span class='rubyid_end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="write_str-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="Vertx::HttpClientRequest (class)">HttpClientRequest</a></span></tt>) <strong>write_str</strong>(str, enc = &quot;UTF-8&quot;, &amp;hndlr) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Write a [String] to the request body.
</p>


  </div>
</div>
<div class="tags">
  <h3>Parameters:</h3>
<ul class="param">
  
    <li>
      
        <span class='name'>str.</span>
      
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>
The string to write.
</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>enc.</span>
      
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>
The encoding to use.
</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>hndlr.</span>
      
      
        <span class='type'>(<tt>Block</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>
The handler will be called when the buffer has actually been written to the
wire.
</p>
</div>
      
    </li>
  
</ul>

<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Vertx::HttpClientRequest (class)">HttpClientRequest</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>
self So multiple operations can be chained.
</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


347
348
349
350</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'src/main/ruby/core/http.rb', line 347</span>

<span class='rubyid_def def kw'>def</span> <span class='rubyid_write_str identifier id'>write_str</span><span class='lparen token'>(</span><span class='rubyid_str identifier id'>str</span><span class='comma token'>,</span> <span class='rubyid_enc identifier id'>enc</span> <span class='assign token'>=</span> <span class='string val'>&quot;UTF-8&quot;</span><span class='comma token'>,</span> <span class='bitand op'>&amp;</span><span class='rubyid_hndlr identifier id'>hndlr</span><span class='rparen token'>)</span>
  <span class='rubyid_@j_del ivar id'>@j_del</span><span class='dot token'>.</span><span class='rubyid_write identifier id'>write</span><span class='lparen token'>(</span><span class='rubyid_str identifier id'>str</span><span class='comma token'>,</span> <span class='rubyid_enc identifier id'>enc</span><span class='rparen token'>)</span>
  <span class='rubyid_self self kw'>self</span>
<span class='rubyid_end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="write_str_and_end-instance_method">
  
    - (<tt>Object</tt>) <strong>write_str_and_end</strong>(str, enc = &quot;UTF-8&quot;) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Same as <span class='object_link'><a href="#write_buffer_and_end-instance_method" title="Vertx::HttpClientRequest#write_buffer_and_end (method)">#write_buffer_and_end</a></span> but writes a String
</p>


  </div>
</div>
<div class="tags">
  <h3>Parameters:</h3>
<ul class="param">
  
    <li>
      
        <span class='name'>str</span>
      
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>
The String to write
</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>enc</span>
      
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>&quot;UTF-8&quot;</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>
The encoding
</p>
</div>
      
    </li>
  
</ul>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


371
372
373</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'src/main/ruby/core/http.rb', line 371</span>

<span class='rubyid_def def kw'>def</span> <span class='rubyid_write_str_and_end identifier id'>write_str_and_end</span><span class='lparen token'>(</span><span class='rubyid_str identifier id'>str</span><span class='comma token'>,</span> <span class='rubyid_enc identifier id'>enc</span> <span class='assign token'>=</span> <span class='string val'>&quot;UTF-8&quot;</span><span class='rparen token'>)</span>
  <span class='rubyid_@j_del ivar id'>@j_del</span><span class='dot token'>.</span><span class='rubyid_end identifier id'>end</span><span class='lparen token'>(</span><span class='rubyid_str identifier id'>str</span><span class='comma token'>,</span> <span class='rubyid_enc identifier id'>enc</span><span class='rparen token'>)</span>
<span class='rubyid_end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

</div>
    
    <div id="footer">
  Generated on Tue Jun 19 16:38:25 2012 by 
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.7.5 (ruby-1.8.7).
</div>

  </body>
</html>