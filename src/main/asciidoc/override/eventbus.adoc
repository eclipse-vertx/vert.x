==== Message Codecs

You can send any object you like across the event bus if you define and register a {@link io.vertx.core.eventbus.MessageCodec message codec} for it.

Message codecs have a name and you specify that name in the {@link io.vertx.core.eventbus.DeliveryOptions}
when sending or publishing the message:

[source,java]
----
{@link docoverride.eventbus.Examples#example10}
----

If you always want the same codec to be used for a particular type then you can register a default codec for it, then
you don't have to specify the codec on each send in the delivery options:

[source,java]
----
{@link docoverride.eventbus.Examples#example11}
----

You unregister a message codec with {@link io.vertx.core.eventbus.EventBus#unregisterCodec}.

Message codecs don't always have to encode and decode as the same type. For example you can write a codec that
allows a MyPOJO class to be sent, but when that message is sent to a handler it arrives as a MyOtherPOJO class.

===== Local codecs

When sending messages to local consumers, you often don't need serialization and deserialization, but you still need to
ensure no thread unsafe data is going to be shared in the message body.
In order to do that, you can create a local codec, that is a codec that works only for local event bus dispatch and makes sure the copy function is properly invoked.
Using {@link io.vertx.core.eventbus.EventBus#registerLocalCodec}, specifying either a {@link io.vertx.core.shareddata.Shareable} class, or a class and the associated function to perform the copy, you create a local codec and register it as default:

[source,java]
----
{@link docoverride.eventbus.Examples#example12}
----

If the type is immutable, you can just use the identity function:

[source,java]
----
{@link docoverride.eventbus.Examples#example13}
----

You can also create a local codec manually using {@link io.vertx.core.eventbus.MessageCodec#localCodec}.
